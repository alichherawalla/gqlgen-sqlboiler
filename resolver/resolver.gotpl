{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "io"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "time"  }}
{{ reserveImport "sync"  }}
{{ reserveImport "errors"  }}
{{ reserveImport "bytes"  }}
{{ reserveImport "github.com/volatiletech/sqlboiler/queries/qm" }}
{{ reserveImport "github.com/web-ridge/gqlgen-sqlboiler/helper" }}
{{ reserveImport "database/sql" }}
{{ reserveImport "github.com/vektah/gqlparser/v2" }}
{{ reserveImport "github.com/vektah/gqlparser/v2/ast" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}

{{ .Imports }}

{{ if .HasRoot }}
	type {{.ResolverType}} struct {
		db *sql.DB
	}
{{ end }}

{{ range $resolver := .Resolvers -}}
	func (r *{{lcFirst $resolver.Object.Name}}{{ucFirst $.ResolverType}}) {{$resolver.Field.GoFieldName}}{{ $resolver.Field.ShortResolverDeclaration }} {
	

		{{- if .IsSingle }}
			dbID := helpers.{{ .Model.Name }}ID(id)
			queryMods := helper.GetPreloadMods(ctx, helpers.{{ .Model.Name|go }}PreloadMap)
			queryMods = append(queryMods, dm.{{ .Model.Name|go }}Where.ID.EQ(dbID))
			{{- if .HasOrganizationID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.OrganizationID.EQ(auth.OrganizationIDFromContext(ctx)))
			{{- end }}
			{{- if .HasUserOrganizationID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.UserOrganizationID.EQ(auth.OrganizationIDFromContext(ctx)))
			{{- end }}
			{{- if .HasUserID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.UserID.EQ(auth.UserIDFromContext(ctx)))
			{{- end }}
			m, err := dm.{{ .Model.PluralName|go }}(queryMods...).One(ctx, r.db)
			return helpers.{{ .Model.Name|go }}ToGraphQL(m, nil), err

		{{- end -}}

		{{- if .IsList }}
			queryMods := helper.GetPreloadMods(ctx, helpers.{{ .Model.Name|go }}PreloadMap)
			a, err := dm.{{ .Model.PluralName|go }}(queryMods...).All(ctx, r.db)
			return helpers.{{ .Model.PluralName|go }}ToGraphQL(a, nil), err

		{{- end -}}

		{{- if .IsCreate }}

			m := helpers.{{ .InputModel.Name }}ToBoiler(&input)

			// Create one-to-one relationships
			{{ $model := .Model -}}
			{{ range $field := .InputModel.Fields -}}
				{{ if $field.IsRelation -}}
					if input.{{ $field.Name|go }} != nil {
						{{ $field.Name }} := helpers.{{ $field.BoilerRelationShipName }}CreateInputToBoiler(input.{{ $field.Name|go }})
						{{ $field.Name }}.OrganizationID = auth.OrganizationIDFromContext(ctx)

						{{ $field.Name }}Input := helpers.{{ $field.BoilerRelationShipName }}CreateInputToBoilerWhitelist(
							ctx,
							"input.{{ $field.Name }}",
							dm.{{ $model.Name }}Columns.OrganizationID,
						)

						// TODO: create the nested relations of {{ $field.Name }}Input if they exist
						if err := {{ $field.Name }}.Insert(ctx, r.db, {{ $field.Name }}Input); err != nil {
							return nil, err
						}
						m.{{ $field.Name|go }}ID = {{ $field.Name }}.ID
					}
					
				{{ end -}}
			{{ end -}}

			// TODO: support all kind of relations

			{{- if .HasOrganizationID }}
				m.OrganizationID = auth.OrganizationIDFromContext(ctx)
			{{- end }}
			{{- if .HasUserOrganizationID }}
				m.UserOrganizationID = auth.OrganizationIDFromContext(ctx)
			{{- end }}
			{{- if .HasUserID }}
				m.UserID = auth.UserIDFromContext(ctx)
			{{- end }}
			if err := m.Insert(ctx, r.db, helpers.{{ .InputModel.Name }}ToBoilerWhitelist(ctx{{ .BoilerWhiteList }}, "input")); err != nil {
				return nil, err
			}

			// resolve requested fields after creating
			queryMods := helper.GetPreloadModsWithLevel(ctx, helpers.{{ .Model.Name|go }}PreloadMap, helpers.{{ .Model.Name|go }}PayloadPreloadLevels.{{ .Model.Name|go }})
			queryMods = append(queryMods, dm.{{ .Model.Name|go }}Where.ID.EQ(m.ID))
			{{- if .HasOrganizationID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.OrganizationID.EQ(auth.OrganizationIDFromContext(ctx)))
			{{- end }}
			{{- if .HasUserOrganizationID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.UserOrganizationID.EQ(auth.OrganizationIDFromContext(ctx)))
			{{- end }}
			{{- if .HasUserID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.UserID.EQ(auth.UserIDFromContext(ctx)))
			{{- end }}
			m, err := dm.{{ .Model.PluralName|go }}(queryMods...).One(ctx, r.db)
			return &fm.{{ .Model.Name }}Payload{
				{{ .Model.Name|go }}: helpers.{{ .Model.Name|go }}ToGraphQL(m, nil),
			}, err

		{{- end -}}

		{{- if .IsUpdate }}
			m := helpers.{{ .InputModel.Name }}ToModelM(ctx, input, "input")

			// Update one-to-one relationships
			{{ $resolver := . -}}
			{{ $model := .Model -}}
			{{ range $field := .InputModel.Fields -}}
				{{ if $field.IsRelation -}}
					if input.{{ $field.Name|go }} != nil {
						dbID := helpers.{{ $field.BoilerRelationShipName }}ID(id)
						nestedM := helpers.{{ $field.BoilerRelationShipName }}UpdateInputToModelM(ctx, *input.{{ $field.Name|go }}, "input.{{ $field.Name }}")
						if _, err := dm.{{ $field.PlularBoilerRelationShipName }}(
							dm.{{ $field.BoilerRelationShipName }}Where.ID.EQ(dbID),
							{{- if $resolver.HasOrganizationID }}
								dm.{{ $field.BoilerRelationShipName }}Where.OrganizationID.EQ(auth.OrganizationIDFromContext(ctx)),
							{{- end }}
							{{- if $resolver.HasUserOrganizationID }}
								dm.{{ $field.BoilerRelationShipName }}Where.UserOrganizationID.EQ(auth.OrganizationIDFromContext(ctx)),
							{{- end }}
							{{- if $resolver.HasUserID }}
								dm.{{ $field.BoilerRelationShipName }}Where.UserID.EQ(auth.UserIDFromContext(ctx)),
							{{- end }}
						).UpdateAll(ctx, r.db, nestedM); err != nil {
							return nil, err
						}
					}
					
				{{ end -}}
			{{ end -}}

			// TODO: support all kind of relations
			dbID := helpers.{{ .Model.Name }}ID(id)
			if _, err := dm.{{ .Model.PluralName }}(
				dm.{{ .Model.Name }}Where.ID.EQ(dbID),
				{{- if .HasOrganizationID }}
					dm.{{ .Model.Name }}Where.OrganizationID.EQ(auth.OrganizationIDFromContext(ctx)),
				{{- end }}
				{{- if .HasUserOrganizationID }}
					dm.{{ .Model.Name }}Where.UserOrganizationID.EQ(auth.OrganizationIDFromContext(ctx)),
				{{- end }}
				{{- if .HasUserID }}
					dm.{{ .Model.Name }}Where.UserID.EQ(auth.UserIDFromContext(ctx)),
				{{- end }}
			).UpdateAll(ctx, r.db, m); err != nil {
				return nil, err
			}

			// resolve requested fields after updating
			queryMods := helper.GetPreloadModsWithLevel(ctx, helpers.{{ .Model.Name|go }}PreloadMap, helpers.{{ .Model.Name|go }}PayloadPreloadLevels.{{ .Model.Name|go }})
			queryMods = append(queryMods, dm.{{ .Model.Name|go }}Where.ID.EQ(dbID))
			{{- if .HasOrganizationID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.OrganizationID.EQ(auth.OrganizationIDFromContext(ctx)))
			{{- end }}
			{{- if .HasUserOrganizationID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.UserOrganizationID.EQ(auth.OrganizationIDFromContext(ctx)))
			{{- end }}
			{{- if .HasUserID }}
				queryMods = append(queryMods, dm.{{ .Model.Name }}Where.UserID.EQ(auth.UserIDFromContext(ctx)))
			{{- end }}

			m, err := dm.{{ .Model.PluralName|go }}(queryMods...).One(ctx, r.db)
			return &fm.{{ .Model.Name|go }}Payload{
				{{ .Model.Name|go }}: helpers.{{ .Model.Name|go }}ToGraphQL(m, nil),
			}, err

		{{- end -}}

		{{- if .IsDelete }}
			queryMods := []qm.QueryMod{
				dm.{{ .Model.Name|go }}Where.ID.EQ(helpers.{{ .Model.Name|go }}ID(id)),
				{{- if .HasOrganizationID }}
					dm.{{ .Model.Name }}Where.OrganizationID.EQ(auth.OrganizationIDFromContext(ctx)),
				{{- end }}
				{{- if .HasUserOrganizationID }}
					dm.{{ .Model.Name }}Where.UserOrganizationID.EQ(auth.OrganizationIDFromContext(ctx)),
				{{- end }}
				{{- if .HasUserID }}
					dm.{{ .Model.Name }}Where.UserID.EQ(auth.UserIDFromContext(ctx)),
				{{- end }}
			}
			 _, err := dm.{{ .Model.PluralName|go }}(queryMods...).DeleteAll(ctx, r.db)
			return &fm.{{ .Model.Name|go }}DeletePayload{
				ID: id,
			}, err

		{{- end -}}

		{{- if .IsBatchCreate }}
		// TODO: Implement batch create
		return nil, nil

		{{- end -}}

		{{- if .IsBatchUpdate }}
		// TODO: Implement input filters / search
		return nil, nil

		{{- end -}}

		{{- if .IsBatchDelete }}
		// TODO: Implement batch delete
		return nil, nil

		{{- end }}
	}

{{ end }}

{{ range $object := .Objects -}}
	func (r *{{$.ResolverType}}) {{$object.Name}}() {{ $object.ResolverInterface | ref }} { return &{{lcFirst $object.Name}}{{ucFirst $.ResolverType}}{r} }
{{ end }}

{{ range $object := .Objects -}}
	type {{lcFirst $object.Name}}{{ucFirst $.ResolverType}} struct { *{{$.ResolverType}} }
{{ end }}

{{ if (ne .RemainingSource "") }}
    // !!! WARNING !!!
    // The code below was going to be deleted when updating resolvers. It has been copied here so you have
    // one last chance to move it out of harms way if you want. There are two reasons this happens:
	//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
	//    it when you're done.
	//  - You have helper methods in this file. Move them out to keep these resolver files clean.
	{{ .RemainingSource }}
{{ end }}