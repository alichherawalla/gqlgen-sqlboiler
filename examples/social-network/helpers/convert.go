// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package helpers

import (
	"github.com/volatiletech/null"
	"github.com/web-ridge/gqlgen-sqlboiler/examples/social-network/graphql_models"
	"github.com/web-ridge/gqlgen-sqlboiler/examples/social-network/models"
	"github.com/web-ridge/gqlgen-sqlboiler/helper"
)

func alreadyConverted(roots []interface{}, check interface{}) bool {
	var matched int
	for _, root := range roots {
		if root == check {
			matched++
		}
	}
	return matched > 2
}

func CommentWithUintID(id uint) *graphql_models.Comment {
	return &graphql_models.Comment{
		ID: CommentIDToGraphQL(id),
	}
}

func CommentWithIntID(id int) *graphql_models.Comment {
	return CommentWithUintID(uint(id))
}

func CommentWithNullDotUintID(id null.Uint) *graphql_models.Comment {
	return CommentWithUintID(id.Uint)
}

func CommentWithNullDotIntID(id null.Int) *graphql_models.Comment {
	return CommentWithUintID(uint(id.Int))
}

func CommentsToGraphQL(am []*models.Comment, roots []interface{}) []*graphql_models.Comment {
	ar := make([]*graphql_models.Comment, len(am))
	for i, m := range am {
		ar[i] = CommentToGraphQL(m, append(roots, m))
	}
	return ar
}

func CommentIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.Comment)
}

func CommentToGraphQL(m *models.Comment, roots []interface{}) *graphql_models.Comment {
	if m == nil {
		return nil
	}

	r := &graphql_models.Comment{
		ID:      CommentIDToGraphQL(m.ID),
		Content: m.Content,
	}

	if helper.UintIsFilled(m.PostID) {
		if m.R != nil && m.R.Post != nil {
			if !alreadyConverted(roots, m.R.Post) {
				r.Post = PostToGraphQL(m.R.Post, append(roots, m))
			}
		} else {
			r.Post = PostWithUintID(m.PostID)
		}
	}

	if helper.UintIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			if !alreadyConverted(roots, m.R.User) {
				r.User = UserToGraphQL(m.R.User, append(roots, m))
			}
		} else {
			r.User = UserWithUintID(m.UserID)
		}
	}
	if m.R != nil && m.R.CommentLikes != nil {
		r.CommentLikes = CommentLikesToGraphQL(m.R.CommentLikes, append(roots, m))
	}

	return r
}

func CommentID(v string) uint {
	return helper.IDToBoiler(v)
}

func CommentIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}

func CommentLikeWithUintID(id uint) *graphql_models.CommentLike {
	return &graphql_models.CommentLike{
		ID: CommentLikeIDToGraphQL(id),
	}
}

func CommentLikeWithIntID(id int) *graphql_models.CommentLike {
	return CommentLikeWithUintID(uint(id))
}

func CommentLikeWithNullDotUintID(id null.Uint) *graphql_models.CommentLike {
	return CommentLikeWithUintID(id.Uint)
}

func CommentLikeWithNullDotIntID(id null.Int) *graphql_models.CommentLike {
	return CommentLikeWithUintID(uint(id.Int))
}

func CommentLikesToGraphQL(am []*models.CommentLike, roots []interface{}) []*graphql_models.CommentLike {
	ar := make([]*graphql_models.CommentLike, len(am))
	for i, m := range am {
		ar[i] = CommentLikeToGraphQL(m, append(roots, m))
	}
	return ar
}

func CommentLikeIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.CommentLike)
}

func CommentLikeToGraphQL(m *models.CommentLike, roots []interface{}) *graphql_models.CommentLike {
	if m == nil {
		return nil
	}

	r := &graphql_models.CommentLike{
		ID:        CommentLikeIDToGraphQL(m.ID),
		LikeType:  m.LikeType,
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
	}

	if helper.UintIsFilled(m.CommentID) {
		if m.R != nil && m.R.Comment != nil {
			if !alreadyConverted(roots, m.R.Comment) {
				r.Comment = CommentToGraphQL(m.R.Comment, append(roots, m))
			}
		} else {
			r.Comment = CommentWithUintID(m.CommentID)
		}
	}

	if helper.UintIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			if !alreadyConverted(roots, m.R.User) {
				r.User = UserToGraphQL(m.R.User, append(roots, m))
			}
		} else {
			r.User = UserWithUintID(m.UserID)
		}
	}

	return r
}

func CommentLikeID(v string) uint {
	return helper.IDToBoiler(v)
}

func CommentLikeIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}

func FriendshipWithUintID(id uint) *graphql_models.Friendship {
	return &graphql_models.Friendship{
		ID: FriendshipIDToGraphQL(id),
	}
}

func FriendshipWithIntID(id int) *graphql_models.Friendship {
	return FriendshipWithUintID(uint(id))
}

func FriendshipWithNullDotUintID(id null.Uint) *graphql_models.Friendship {
	return FriendshipWithUintID(id.Uint)
}

func FriendshipWithNullDotIntID(id null.Int) *graphql_models.Friendship {
	return FriendshipWithUintID(uint(id.Int))
}

func FriendshipsToGraphQL(am []*models.Friendship, roots []interface{}) []*graphql_models.Friendship {
	ar := make([]*graphql_models.Friendship, len(am))
	for i, m := range am {
		ar[i] = FriendshipToGraphQL(m, append(roots, m))
	}
	return ar
}

func FriendshipIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.Friendship)
}

func FriendshipToGraphQL(m *models.Friendship, roots []interface{}) *graphql_models.Friendship {
	if m == nil {
		return nil
	}

	r := &graphql_models.Friendship{
		ID:        FriendshipIDToGraphQL(m.ID),
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
	}

	if m.R != nil && m.R.Users != nil {
		r.Users = UsersToGraphQL(m.R.Users, append(roots, m))
	}

	return r
}

func FriendshipID(v string) uint {
	return helper.IDToBoiler(v)
}

func FriendshipIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}

func ImageWithUintID(id uint) *graphql_models.Image {
	return &graphql_models.Image{
		ID: ImageIDToGraphQL(id),
	}
}

func ImageWithIntID(id int) *graphql_models.Image {
	return ImageWithUintID(uint(id))
}

func ImageWithNullDotUintID(id null.Uint) *graphql_models.Image {
	return ImageWithUintID(id.Uint)
}

func ImageWithNullDotIntID(id null.Int) *graphql_models.Image {
	return ImageWithUintID(uint(id.Int))
}

func ImagesToGraphQL(am []*models.Image, roots []interface{}) []*graphql_models.Image {
	ar := make([]*graphql_models.Image, len(am))
	for i, m := range am {
		ar[i] = ImageToGraphQL(m, append(roots, m))
	}
	return ar
}

func ImageIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.Image)
}

func ImageToGraphQL(m *models.Image, roots []interface{}) *graphql_models.Image {
	if m == nil {
		return nil
	}

	r := &graphql_models.Image{
		ID:          ImageIDToGraphQL(m.ID),
		Views:       helper.NullDotIntToPointerInt(m.Views),
		OriginalURL: helper.NullDotStringToPointerString(m.OriginalURL),
	}

	if helper.UintIsFilled(m.PostID) {
		if m.R != nil && m.R.Post != nil {
			if !alreadyConverted(roots, m.R.Post) {
				r.Post = PostToGraphQL(m.R.Post, append(roots, m))
			}
		} else {
			r.Post = PostWithUintID(m.PostID)
		}
	}
	if m.R != nil && m.R.ImageVariations != nil {
		r.ImageVariations = ImageVariationsToGraphQL(m.R.ImageVariations, append(roots, m))
	}

	return r
}

func ImageID(v string) uint {
	return helper.IDToBoiler(v)
}

func ImageIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}

func ImageVariationWithUintID(id uint) *graphql_models.ImageVariation {
	return &graphql_models.ImageVariation{
		ID: ImageVariationIDToGraphQL(id),
	}
}

func ImageVariationWithIntID(id int) *graphql_models.ImageVariation {
	return ImageVariationWithUintID(uint(id))
}

func ImageVariationWithNullDotUintID(id null.Uint) *graphql_models.ImageVariation {
	return ImageVariationWithUintID(id.Uint)
}

func ImageVariationWithNullDotIntID(id null.Int) *graphql_models.ImageVariation {
	return ImageVariationWithUintID(uint(id.Int))
}

func ImageVariationsToGraphQL(am []*models.ImageVariation, roots []interface{}) []*graphql_models.ImageVariation {
	ar := make([]*graphql_models.ImageVariation, len(am))
	for i, m := range am {
		ar[i] = ImageVariationToGraphQL(m, append(roots, m))
	}
	return ar
}

func ImageVariationIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.ImageVariation)
}

func ImageVariationToGraphQL(m *models.ImageVariation, roots []interface{}) *graphql_models.ImageVariation {
	if m == nil {
		return nil
	}

	r := &graphql_models.ImageVariation{
		ID: ImageVariationIDToGraphQL(m.ID),
	}

	if helper.UintIsFilled(m.ImageID) {
		if m.R != nil && m.R.Image != nil {
			if !alreadyConverted(roots, m.R.Image) {
				r.Image = ImageToGraphQL(m.R.Image, append(roots, m))
			}
		} else {
			r.Image = ImageWithUintID(m.ImageID)
		}
	}

	return r
}

func ImageVariationID(v string) uint {
	return helper.IDToBoiler(v)
}

func ImageVariationIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}

func LikeWithUintID(id uint) *graphql_models.Like {
	return &graphql_models.Like{
		ID: LikeIDToGraphQL(id),
	}
}

func LikeWithIntID(id int) *graphql_models.Like {
	return LikeWithUintID(uint(id))
}

func LikeWithNullDotUintID(id null.Uint) *graphql_models.Like {
	return LikeWithUintID(id.Uint)
}

func LikeWithNullDotIntID(id null.Int) *graphql_models.Like {
	return LikeWithUintID(uint(id.Int))
}

func LikesToGraphQL(am []*models.Like, roots []interface{}) []*graphql_models.Like {
	ar := make([]*graphql_models.Like, len(am))
	for i, m := range am {
		ar[i] = LikeToGraphQL(m, append(roots, m))
	}
	return ar
}

func LikeIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.Like)
}

func LikeToGraphQL(m *models.Like, roots []interface{}) *graphql_models.Like {
	if m == nil {
		return nil
	}

	r := &graphql_models.Like{
		ID:        LikeIDToGraphQL(m.ID),
		LikeType:  m.LikeType,
		CreatedAt: helper.NullDotTimeToPointerInt(m.CreatedAt),
	}

	if helper.UintIsFilled(m.PostID) {
		if m.R != nil && m.R.Post != nil {
			if !alreadyConverted(roots, m.R.Post) {
				r.Post = PostToGraphQL(m.R.Post, append(roots, m))
			}
		} else {
			r.Post = PostWithUintID(m.PostID)
		}
	}

	if helper.UintIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			if !alreadyConverted(roots, m.R.User) {
				r.User = UserToGraphQL(m.R.User, append(roots, m))
			}
		} else {
			r.User = UserWithUintID(m.UserID)
		}
	}

	return r
}

func LikeID(v string) uint {
	return helper.IDToBoiler(v)
}

func LikeIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}

func PostWithUintID(id uint) *graphql_models.Post {
	return &graphql_models.Post{
		ID: PostIDToGraphQL(id),
	}
}

func PostWithIntID(id int) *graphql_models.Post {
	return PostWithUintID(uint(id))
}

func PostWithNullDotUintID(id null.Uint) *graphql_models.Post {
	return PostWithUintID(id.Uint)
}

func PostWithNullDotIntID(id null.Int) *graphql_models.Post {
	return PostWithUintID(uint(id.Int))
}

func PostsToGraphQL(am []*models.Post, roots []interface{}) []*graphql_models.Post {
	ar := make([]*graphql_models.Post, len(am))
	for i, m := range am {
		ar[i] = PostToGraphQL(m, append(roots, m))
	}
	return ar
}

func PostIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.Post)
}

func PostToGraphQL(m *models.Post, roots []interface{}) *graphql_models.Post {
	if m == nil {
		return nil
	}

	r := &graphql_models.Post{
		ID:      PostIDToGraphQL(m.ID),
		Content: m.Content,
	}

	if helper.UintIsFilled(m.UserID) {
		if m.R != nil && m.R.User != nil {
			if !alreadyConverted(roots, m.R.User) {
				r.User = UserToGraphQL(m.R.User, append(roots, m))
			}
		} else {
			r.User = UserWithUintID(m.UserID)
		}
	}
	if m.R != nil && m.R.Comments != nil {
		r.Comments = CommentsToGraphQL(m.R.Comments, append(roots, m))
	}
	if m.R != nil && m.R.Images != nil {
		r.Images = ImagesToGraphQL(m.R.Images, append(roots, m))
	}
	if m.R != nil && m.R.Likes != nil {
		r.Likes = LikesToGraphQL(m.R.Likes, append(roots, m))
	}

	return r
}

func PostID(v string) uint {
	return helper.IDToBoiler(v)
}

func PostIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}

func UserWithUintID(id uint) *graphql_models.User {
	return &graphql_models.User{
		ID: UserIDToGraphQL(id),
	}
}

func UserWithIntID(id int) *graphql_models.User {
	return UserWithUintID(uint(id))
}

func UserWithNullDotUintID(id null.Uint) *graphql_models.User {
	return UserWithUintID(id.Uint)
}

func UserWithNullDotIntID(id null.Int) *graphql_models.User {
	return UserWithUintID(uint(id.Int))
}

func UsersToGraphQL(am []*models.User, roots []interface{}) []*graphql_models.User {
	ar := make([]*graphql_models.User, len(am))
	for i, m := range am {
		ar[i] = UserToGraphQL(m, append(roots, m))
	}
	return ar
}

func UserIDToGraphQL(v uint) string {
	return helper.IDToGraphQL(v, models.TableNames.User)
}

func UserToGraphQL(m *models.User, roots []interface{}) *graphql_models.User {
	if m == nil {
		return nil
	}

	r := &graphql_models.User{
		ID:        UserIDToGraphQL(m.ID),
		FirstName: m.FirstName,
		LastName:  m.LastName,
		Email:     m.Email,
	}

	if m.R != nil && m.R.Comments != nil {
		r.Comments = CommentsToGraphQL(m.R.Comments, append(roots, m))
	}
	if m.R != nil && m.R.CommentLikes != nil {
		r.CommentLikes = CommentLikesToGraphQL(m.R.CommentLikes, append(roots, m))
	}
	if m.R != nil && m.R.Likes != nil {
		r.Likes = LikesToGraphQL(m.R.Likes, append(roots, m))
	}
	if m.R != nil && m.R.Posts != nil {
		r.Posts = PostsToGraphQL(m.R.Posts, append(roots, m))
	}
	if m.R != nil && m.R.Friendships != nil {
		r.Friendships = FriendshipsToGraphQL(m.R.Friendships, append(roots, m))
	}

	return r
}

func UserID(v string) uint {
	return helper.IDToBoiler(v)
}

func UserIDs(a []string) []uint {
	return helper.IDsToBoiler(a)
}
