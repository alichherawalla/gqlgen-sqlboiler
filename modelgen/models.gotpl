{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "io"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "time"  }}
{{ reserveImport "sync"  }}
{{ reserveImport "errors"  }}
{{ reserveImport "bytes"  }}
{{ reserveImport "strings"  }}
{{ reserveImport "github.com/volatiletech/sqlboiler/boil"}}
{{ reserveImport "github.com/ericlagergren/decimal"  }}
{{ reserveImport "github.com/volatiletech/null"  }}
{{ reserveImport "github.com/volatiletech/sqlboiler/types"  }}
{{ reserveImport "github.com/web-ridge/gqlgen-sqlboiler/helper" }}
{{ reserveImport "github.com/vektah/gqlparser" }}
{{ reserveImport "github.com/vektah/gqlparser/ast" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}
{{ reserveImport "github.com/volatiletech/sqlboiler/queries/qm" }}
{{ reserveImport "database/sql" }}
{{ reserveImport  $.BackendModelsPath }}
{{ reserveImport  $.FrontendModelsPath }}

func getInputFromContext(ctx context.Context, key string) map[string]interface{} {
	requestContext := graphql.GetRequestContext(ctx)
	m, ok := requestContext.Variables[key].(map[string]interface{})
	if !ok {
		fmt.Println("can not get input from context")
	}
	return m
}

{{ range $model := .Models }}
	{{with .Description }} {{.|prefixLines "// "}} {{end}}

	{{- if not .IsInput -}}
	var {{ $model.Name|go }}PreloadMap = map[string]helper.ColumnSetting{
		{{ range $field := .Fields }}
			{{- if $field.IsRelation -}}
				{{- if $field.IsPlural }}
					"{{ $field.PluralName }}":        helper.ColumnSetting{Name: models.{{ $model.Name|go }}Rels.{{ $field.BoilerName|go }}},
				{{- else }}
					"{{ $field.Name }}":        helper.ColumnSetting{Name: models.{{ $model.Name|go }}Rels.{{ $field.BoilerName|go }}, IDAvailable: true},
				{{- end -}}
			{{- end -}}
		{{- end }}
		
		{{ range $relationModel := $.Models }}
	
				{{ range $field := .Fields }}
					{{ range $relationField := $relationModel.Fields }}
						{{- if $field.IsRelation -}}
							{{- if $relationField.IsRelation -}}
								{{- if $relationField.IsPlural }}
								// ?? {{$relationModel.Name}} === {{$model.Name}}
								{{- if eq $relationModel.Name  $model.Name -}}
								// YESS {{$relationModel.Name}} === {{$model.Name}}
								//3
									"{{ $field.Name }}.{{ $relationField.Name }}":        helper.ColumnSetting{Name: models.{{ $model.Name|go }}Rels.{{ $relationField.BoilerName|go }} + "."+models.{{ $relationModel.Name|go }}Rels.{{ $relationField.BoilerName|go }}},
								{{- else }}

								//4
									"{{ $field.Name }}.{{ $relationField.Name }}":        helper.ColumnSetting{Name: models.{{ $model.Name|go }}Rels.{{ $relationField.BoilerName|go }} + "."+models.{{ $relationModel.Name|go }}Rels.{{ $relationField.BoilerName|go }}},
								{{- end -}}
							{{- end }}
						{{- end }}
					{{- end }}
				{{- end }}
			{{- end }}
		{{- end }}
	}
	{{ end }}

	{{- if not .IsInput -}}
		func Get{{ .Name|go }}(ctx context.Context, db *sql.DB, whereFilters ...qm.QueryMod) (*graphql_models.{{ .Name|go }}, error) {
			queryMods := helper.GetPreloadMods(ctx, {{ .Name|go }}PreloadMap)
			queryMods = append(queryMods, whereFilters...)
			m, err := models.{{ .PluralName|go }}(queryMods...).One(ctx, db)
			return {{ .Name|go }}ToGraphQL(m, m), err
		}
		func Get{{ .PluralName|go }}(ctx context.Context, db *sql.DB, whereFilters ...qm.QueryMod) ([]*graphql_models.{{ .Name|go }}, error) {
			queryMods := helper.GetPreloadMods(ctx,{{ .Name|go }}PreloadMap)
			queryMods = append(queryMods, whereFilters...)
			a, err := models.{{ .PluralName|go }}(queryMods...).All(ctx, db)
			return {{ .PluralName|go }}ToGraphQL(a, nil), err
		}
		func {{ .Name|go }}WithIntID(id int) *graphql_models.{{ .Name|go }} {
			return &graphql_models.{{ .Name|go }}{
				ID: helper.IntToStringIDUnique(id, "{{ $model.Name|go }}"),
			}
		}
		func {{ .Name|go }}WithUintID(id uint) *graphql_models.{{ .Name|go }} {
			return &graphql_models.{{ .Name|go }}{
				ID: helper.UintToStringIDUnique(id, "{{ $model.Name|go }}"),
			}
		}

		func {{ .Name|go }}WithNullDotUintID(id null.Uint) *graphql_models.{{ .Name|go }} {
			return {{ .Name|go }}WithUintID(id.Uint)
		}
		func {{ .Name|go }}WithNullDotIntID(id null.Int) *graphql_models.{{ .Name|go }} {
			return {{ .Name|go }}WithIntID(id.Int)
		}
		func {{ .PluralName|go }}ToGraphQL(am []*models.{{ .Name|go }}, root interface{})( []*graphql_models.{{ .Name|go }}) {
			ar := make([]*graphql_models.{{ .Name|go }}, len(am))
			for i,m := range am {
				ar[i] = {{ .Name|go }}ToGraphQL(m, root)
			}
			return ar
		}

	
		{{ range $field := .Fields }}
			{{- if $field.IsId -}}
				func {{ $model.Name|go }}IDUnique(v {{$field.BoilerType}})({{$field.GraphType}}) {
					return helper.{{ $field.CustomToFunction }}IDUnique(v, "{{ $model.Name|go }}")
				}
			{{- end -}}
		{{- end }}
	


	func {{ .Name|go }}ToGraphQL(m *models.{{ .BoilerName|go }}, root interface{})( *graphql_models.{{ .Name|go }}) {
		if m == nil {
			return nil
		}
		r := &graphql_models.{{ .Name|go }}{
			{{ range $field := .Fields }}
				{{- with .Description }}
					{{.|prefixLines "// "}}
				{{- end}}
				{{- if $field.IsId -}}
					{{- $field.Name|go }}:  {{ $field.CustomBoilerIDFunction|go }}(m.{{ $field.BoilerName|go }}),
				{{- else if $field.IsRelation -}}
				{{- else if $field.IsCustomFunction }}
					{{ $field.Name|go }}: helper.{{ $field.CustomToFunction }}(m.{{ $field.BoilerName|go }}),
				{{- else }}	
					{{ $field.Name|go }}: m.{{ $field.BoilerName|go }},
				{{- end -}}
			{{- end }}
		}

		{{- range $field := .Fields }}
	
			{{- if $field.IsRelation }}
				{{- if $field.IsPlural }}
					if m.R != nil && m.R.{{ $field.Name|go }} != nil  {
						r.{{ $field.Name|go }} = {{ $field.Name|go }}ToGraphQL(m.R.{{ $field.Name|go }}, m)
					} 
				{{- else }}	
				
				if !helper.{{ $field.CustomBoilerType }}IsZero(m.{{ $field.Name|go }}ID) {
					if m.R != nil && m.R.{{ $field.Name|go }} != nil  {
						rootValue, sameStructAsRoot := root.(*models.{{ $field.BoilerName|go }})
						if !sameStructAsRoot || rootValue != m.R.{{ $field.Name|go }} {
							r.{{ $field.Name|go }} ={{ $field.Name|go }}ToGraphQL(m.R.{{ $field.Name|go }}, m)
						}
					} else {
						r.{{ $field.Name|go }} = {{ $field.Name|go }}With{{ $field.CustomBoilerType|go }}ID(m.{{ $field.Name|go }}ID)
					}
				}
				{{- end -}}
			{{end -}}
		{{- end }}

		return r
	}

		{{ range $field := .Fields }}
			{{- if $field.IsId -}}
				func {{ $model.Name|go }}ID(v {{$field.GraphType}})({{$field.BoilerType}}) {
					return helper.{{ $field.CustomFromFunction }}ID(v, "{{ $model.Name|go }}")
				}
				func {{ $model.Name|go }}IDNullable(v *{{$field.GraphType}})(null.{{$field.BoilerType|go}}) {
					if v == nil {
						return null.{{$field.BoilerType|go}}{
							Valid: false,
						}
					}
					s := {{ $model.Name|go }}ID(*v)
					return null.{{$field.BoilerType|go}}{
						Valid: s != 0,
						{{$field.BoilerType|go}}: s,
					}
				}
				func {{ $model.Name|go }}IDsToInts(a []string) []{{$field.BoilerType}} {
					r := make([]int, len(a))
					for i, v := range a {
						r[i] = {{ $model.Name|go }}ID(v)
					}
					return r
				}
			{{- end -}}
		{{- end }}
	{{- end }}
	{{- if .IsInput }}
				
		func {{ .PluralName|go }}ToBoiler(am []*graphql_models.{{ .Name|go }})( []*models.{{ .BoilerName|go }}) {
			ar := make([]*models.{{ .BoilerName|go }}, len(am))
			for i,m := range am {
				ar[i] = {{ .Name|go }}ToBoiler(m)
			}
			return ar
		}
		
		func {{ .Name|go }}ToBoiler(m *graphql_models.{{ .Name|go }})( *models.{{ .BoilerName|go }}) {
			if m == nil {
				return nil
			}	
			r := &models.{{ .BoilerName|go }}{
			{{ range $field := .Fields -}}
				{{ if $field.IsId }}
					{{- $field.BoilerName|go }} : {{ $field.CustomGraphIDFunction|go }}(m.{{ $field.Name|go }}),
				{{ else if $field.IsRelation }}
				{{ else if $field.IsCustomFunction }}
					{{- $field.BoilerName|go }} : helper.{{ $field.CustomFromFunction }}(m.{{ $field.Name|go }}),
				{{ else }}	
					{{- $field.BoilerName|go }}: m.{{ $field.Name|go }},
				{{ end }}
			{{- end -}}
			}
			return r
		}
		func {{ .Name|go }}ToModelM(ctx context.Context, m graphql_models.{{ .Name|go }}) models.M {
			input := getInputFromContext(ctx, "input")
			modelM := models.M{}
			for key, _ := range input {
				switch key {
					{{ range $field := .Fields -}}
					case "{{ $field.CamelCaseName }}":
						{{ if $field.IsId -}}
							modelM[models.{{ $model.BoilerName|go }}Columns.{{- $field.BoilerName|go }}] = {{ $field.CustomGraphIDFunction|go }}(m.{{ $field.Name|go }})
						{{ else if $field.IsRelation -}}
						{{ else if $field.IsCustomFunction -}}
							modelM[models.{{ $model.BoilerName|go }}Columns.{{- $field.BoilerName|go }}] = helper.{{ $field.CustomFromFunction }}(m.{{ $field.Name|go }})
						{{ else -}}	
							modelM[models.{{ $model.BoilerName|go }}Columns.{{- $field.BoilerName|go }}] = m.{{ $field.Name|go }}
						{{ end -}}
					{{ end -}}
				}
			}
			return modelM
		}
		func {{ .Name|go }}ToBoilerWhitelist(ctx context.Context, extraColumns ...string) boil.Columns {
			input := getInputFromContext(ctx, "input")
			columnsWhichAreSet := []string{}
			for key, _ := range input {
				switch key {
					{{ range $field := .Fields -}}
					case "{{ $field.CamelCaseName }}":
						columnsWhichAreSet = append(columnsWhichAreSet, models.{{ $model.BoilerName|go }}Columns.{{- $field.BoilerName|go }})
					{{ end -}}
				}
			}
			columnsWhichAreSet = append(columnsWhichAreSet, extraColumns...)
			return boil.Whitelist(columnsWhichAreSet...)
		}
	{{- end }}
{{- end }}
